# C++开源框架：Workflow的异步编程范式理念

开源至今8个月，Workflow作为一个github上拥有4k星星的C++项目，备受开发者们的关注和认可。作为项目的开发者之一的我，感激之余，也认为这是一个非常好的时机，去从面向开源社区和广大开发者所关心的角度，给Workflow进行一个全方位的介绍，希望这种异步调度编程范式的理念可以与大家碰撞出更多思想上的火花。

### 一、基本介绍
Workflow在开源之前就支撑搜狗绝大部分后端C++在线服务，包括所有搜索服务，云输入法，在线广告等，每日处理数百亿请求。开源后其实一直没有一个对标的作品，因为Workflow的定位是：

一个并行计算与异步通信融为一体的编程范式。

怎么理解呢？我们可以从以下几个方面概括Workflow的基本功能：

- 包括通信、计算、文件IO、定时器、计数器等异步资源
- 创新性引入的任务流概念，各种异步任务都可以被对等地组装起来实现复杂的业务逻辑
- 内部自带多种通用协议(Http, Redis, MySQL, Kafka)
- 跨平台、支持多种操作系统(linux/MacOS/Windows)
- 自带命名服务，包括进程内服务治理与负载均衡
 
Workflow只用了半年就在公司内部迅速普及，成为C++编程的标准框架，基本能够协助业务模块提升好几倍性能，轻松把cpu吃满，而在开源后越来越多的开发者陆续点亮了Workflow不同的使用场景技能树，一路以来被认可真的非常振奋人心。
根据众多开发者的使用场景，我认为这主要得益于Workflow的几个最受青睐的特点：

1. 计算与通信融为一体：特别适合需要网络通信的重计算模块；
2. 极其优异的性能不单网络、磁盘IO或CPU计算，而是着眼于让所有异步资源都尽可能被全部调起；
3. 架构层次适合组装与复用提出算法、协议、业务逻辑分离的编程思想，统一的开发模式让一切都以任务形式组装；
4. 用户体验友好接口简洁、提供常用协议、使用方式符合人类思维；

我们来看一下写一个C++的Http异步Server可以多简洁：

```cpp
#include <stdio.h>
#include "workflow/WFHttpServer.h"

int main()
{
    WFHttpServer server([](WFHttpTask *task) {
        task->get_resp()->append_output_body("<html>Hello World!</html>");
    });

    if (server.start(8888) == 0) {
        getchar(); // press "Enter" to end.
        server.stop();
    }

    return 0;
}
```

纯异步，无阻塞，代码就是这么清新优雅！而且这里我们可以看到Workflow的task了，所以第二部分我们来从``异步``->``任务``->``任务流``来介绍一下Workflow的整体架构设计层次。

### 二、架构设计

**1、异步资源的层级**

Workflow的核心功能，是异步调度。调度什么呢？我们认为一切资源都是可以被异步调度的，目前Workflow封装了六种资源：网络、文件IO、CPU、GPU、计时器、计数器，资源管理层级如下图：

<img src="https://raw.githubusercontent.com/wiki/sogou/srpc/picture1.png" width = "800" height = "500" alt="picture1" align=center />

**2、从异步资源封装出任务层次**

通过上图可以看到，所有异步资源一视同仁又互相独立管理，计算通信一体化，可以尽可能把机器所有资源跑满。在资源之上，我们需要层层递进地封装：

1. 封装调度器：任何资源只要提供了可以被异步操作的方式，则都可以封装出它的调度器，对该资源做管理和复用；
2. 封装调度的基本单位：具体资源需要封装出基本单位，由用户请求触发、框架创建基本单位并交给调度器；
3. 封装被统一执行的基本调度单位：基本单位除了可以被调度器使用，还应该封装出统一的方式，供用户的调度逻辑使用。

根据六种资源的每个层次，可以梳理出以下表格：

<img src="https://raw.githubusercontent.com/wiki/sogou/srpc/picture2.png" alt="picture2" align=center />

**3、引入任务流革新回调函数的使用模式**

Workflow的每种异步资源都是基于回调函数模式，原始的做法会带来代码碎片化的问题，但Workflow创新性地引入任务流，打开了回调模式的全新使用体验：

- 我们提供了Series作串行任务流、Parallel作并行任务流；
- 不同的类型的任务都可以互相拼装，组成复杂的业务逻辑；
- 流图中的任务可以一开始创建、也可以在回调函数里动态往后创建；

这里可以给出一个复合任务流例子，通过统一的接口和任务的混装，用户可以借用任务去封装基本代码片段、而借助任务流去实现更上层的代码逻辑，使用模式非常清晰明了：

<img src="https://raw.githubusercontent.com/wiki/sogou/srpc/picture3.png" width = "800" height = "400" alt="picture3" align=center />

### 三、编程范式

任务流图介绍到这里，我们对Workflow提供的理念就呼之欲出了。Worklfow的世界认为：

``程序`` = ``协议`` + ``算法`` + ``任务流``

* 协议：大多数情况下使用内置的通用网络协议或各种rpc
* 算法：算法与协议对称。如果说协议的调用是rpc，算法的调用就是一次apc（Async Procedure Call）
* 任务流：任务流就是实际的业务逻辑，就是把开发好的协议与算法放在流程图里使用，除了串行、并行，Workflow还可以组建非闭合的DAG

这三部分互相独立，因而用Workflow非常易于拼装和实现二次开发。作为编程引擎，其实这些都是为一个完备的编程范式所必备的特点。

Workflow有三个约定：

1. 串行是由任务组成的
2. 并行是由串行组成的
3. 并行是一种任务

基于以上可以看出，workflow是一套完备的、可以收敛一切循环和控制的编程范式。

最后是个人对完备的编程范式的一些解读：
- 由于可以串行，我们就可以动态建流图，并且无限执行下去；
- 由于可以并行，并行的是各个串行流，我们可以对多个并发执行的流在完成时做收敛；
- 并行本身是一种任务，因此可以加到串行流图里，即每个任务都可以是一个复合任务组装而成，组装后提供给其他使用者使用，而使用者不需要关心复合任务内部细节，进一步组装。


到此就是对Workflow的全面介绍了：从业务使用特点，到架构层次的异步资源、任务封装、任务流，最后引出Workflow整体作为一个异步编程范式的理念所在。Workflow开源的时间还非常短，而期间也让我们感受到了开源世界的许多善意，更让我们对之后的项目发展充满了信心！希望Worklfow能够在优异的性能和易用性上，为更多广大开发者提供一个实用的基础框架，也更希望能够在设计理念和代码设计上，引发更多的交流和技术的创新。
